---
title: "SDK utilities"
description: "Use helper functions to validate inputs and clean up temporary files."
---

The Runpod SDK includes helper functions to make your handlers more robust and easier to maintain. These utilities handle common tasks like input validation and cleanup.

## Input validation

The validator utility ensures your handler receives the correct input format before processing. This helps catch errors early and prevents issues from unexpected or malformed inputs.

### Import the validator

```python
from runpod.serverless.utils.rp_validator import validate
```

### Define a schema

Define your schema as a dictionary with validation rules for each input field:

```python
schema = {
    "text": {
        "type": str,
        "required": True,
    },
    "max_length": {
        "type": int,
        "required": False,
        "default": 100,
        "constraints": lambda x: x > 0,
    },
}
```

Schema properties:
- `type` (required): Expected input type (e.g., `str`, `int`, `float`, `bool`).
- `required` (default: `False`): Whether the field is required.
- `default` (default: `None`): Default value if input is not provided.
- `constraints` (optional): A lambda function that returns `True` or `False` to validate the value.

### Validate input in your handler

```python
import runpod
from runpod.serverless.utils.rp_validator import validate

schema = {
    "text": {
        "type": str,
        "required": True,
    },
    "max_length": {
        "type": int,
        "required": False,
        "default": 100,
        "constraints": lambda x: x > 0,
    },
}


def handler(event):
    try:
        validated_input = validate(event["input"], schema)
        if "errors" in validated_input:
            return {"error": validated_input["errors"]}

        text = validated_input["validated_input"]["text"]
        max_length = validated_input["validated_input"]["max_length"]

        result = text[:max_length]
        return {"output": result}
    except Exception as e:
        return {"error": str(e)}


runpod.serverless.start({"handler": handler})
```

### Test the validator

Save your handler as `your_handler.py` and test it:

```sh
python your_handler.py --test_input '{"input": {"text": "Hello, world!", "max_length": 5}}'
```

Or create a `test_input.json` file:

```json test_input.json
{
  "input": {
    "text": "The quick brown fox jumps over the lazy dog",
    "max_length": 50
  }
}
```

## Cleanup utility

The cleanup utility removes temporary files and folders after your handler completes processing. This prevents disk space issues from accumulating temporary data.

### Import the cleanup function

```python
from runpod.serverless.utils.rp_cleanup import clean
```

### Default behavior

By default, `clean()` removes these directories and files:
- `input_objects/`
- `output_objects/`
- `job_files/`
- `output.zip`

### Use cleanup in your handler

```python
import runpod
from runpod.serverless.utils.rp_cleanup import clean
import requests
import os


def download_image(url, save_path):
    response = requests.get(url)
    if response.status_code == 200:
        with open(save_path, "wb") as file:
            file.write(response.content)
        return True
    return False


def handler(event):
    try:
        image_url = event["input"]["image_url"]

        # Create a temporary directory
        os.makedirs("temp_images", exist_ok=True)
        image_path = "temp_images/downloaded_image.jpg"

        # Download the image
        if not download_image(image_url, image_path):
            raise Exception("Failed to download image")

        # Process the image (your code here)
        result = f"Processed image from: {image_url}"

        # Cleanup after processing
        clean(folder_list=["temp_images"])

        return {"output": result}
    except Exception as e:
        # Attempt cleanup even on error
        clean(folder_list=["temp_images"])
        return {"error": str(e)}


runpod.serverless.start({"handler": handler})
```

### Custom cleanup

Specify additional folders to remove by passing a list to `clean()`:

```python
clean(folder_list=["temp_images", "cache", "downloads"])
```

### Best practices

- Call `clean()` at the end of your handler to ensure proper cleanup.
- Use try-except blocks to handle errors during cleanup.
- Be cautious when adding custom folders to the cleanup list.
- Consider logging cleanup actions for debugging purposes.

## Next steps

Learn about other development tools:

- [Local testing](/serverless/development/local-testing): Test your handler before deploying.
- [Pod-first development](/serverless/development/pod-first-development): Develop on a Pod before deploying to Serverless.
- [Environment variables](/serverless/development/environment-variables): Configure your workers without hardcoding credentials.
